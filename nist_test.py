#
# Copyright (C) 2019 Luca Pasqualini
# University of Siena - Artificial Intelligence Laboratory - SAILab
#
# Inspired by the work of David Johnston (C) 2017: https://github.com/dj-on-github/sp800_22_tests
#
# NistRng is licensed under a BSD 3-Clause.
#
# You should have received a copy of the license along with this
# work. If not, see <https://opensource.org/licenses/BSD-3-Clause>.

# Import packages

import numpy as np
import math

# Import src

from nistrng import *


# --------- VARIABLES DE CONTROL ---------- #
#
# Polinomios de Chebyshev
# x0, y0, m ,n
CHEBYSHEV_X_0 = 0.4811295983708204
CHEBYSHEV_Y_0 = -0.3437604907376320
CHEBYSHEV_N = 5.0468764305551317
CHEBYSHEV_M = 9.0078127384258552

# Funcion Tienda
# a
TIENDA_U = 1.5546548465465465
TIENDA_X_0 = 0.5811295983708204

# Funcion Logistica
# u
LOGISTICA_U = 3.71
LOGISTICA_X_0 = 0.6734678425981357
# ---------- VARIABLES DE CONTROL ---------- #


def normalizationValues(x):
    n1 = math.floor(x * 10**5)
    n2 = math.floor(x * 10**9) - (n1 * 10**4)
    return (n1 ^ n2) % 256


def polynomialSequence(x, m):
    return math.cos(m*math.acos(x))


def key_data(lenght):

    def polynomialSequenceX(x): return math.cos(CHEBYSHEV_M*math.acos(x))
    def polynomialSequenceY(y): return math.cos(CHEBYSHEV_N*math.acos(y))

    x = CHEBYSHEV_X_0
    y = CHEBYSHEV_Y_0

    list_keys = []
    for i in range(0, int(lenght/2)):
        x = polynomialSequenceX(x)
        y = polynomialSequenceY(y)

        list_keys.append(normalizationValues(
            x))
        list_keys.append(normalizationValues(
            y))

    return list_keys


def generate_data(lenght):

    def tend_map_iterator(x_0):
        x_i = 0
        if x_0 >= 0 and x_0 < 0.5:
            x_i = x_0 * TIENDA_U
        else:
            x_i = (1 - x_0) * TIENDA_U

        return x_i

    def logistic_map_iterator(x_0):
        x_i = LOGISTICA_U * x_0 * (1 - x_0)
        return x_i

    list_positions_tent = []
    list_positions_logistic = []
    list_keys = []

    s_i = CHEBYSHEV_X_0
    t_i = CHEBYSHEV_Y_0
    m = CHEBYSHEV_M
    n = CHEBYSHEV_N
    x_i = TIENDA_X_0
    y_i = LOGISTICA_X_0

    for i in range(0, lenght + 51):
        x_i = tend_map_iterator(x_i)
        y_i = logistic_map_iterator(y_i)

        if i > 50:
            # x_final = math.floor((x_i * 10**2) % 4)
            # list_positions_tent.append(x_final)
            list_positions_tent.append(normalizationValues(x_i))

            # y_final = math.floor((y_i * 10**2) % 4)
            # list_positions_logistic.append(y_final)
            list_positions_logistic.append(normalizationValues(y_i))

        if i < int(lenght/2):
            s_i = polynomialSequence(s_i, m)
            t_i = polynomialSequence(t_i, n)
            list_keys.append(normalizationValues(s_i))
            list_keys.append(normalizationValues(t_i))

    return list_keys, list_positions_tent, list_positions_logistic


def test(sequence_name, sequence_data):
    print("|--------------------------------|", sequence_name,
          "|--------------------------------------------|")
    print("Random", sequence_name, "sequence lenght:")
    print(len(sequence_data))
    # Check the eligibility of the test and generate an eligible battery from the default NIST-sp800-22r1a battery
    eligible_battery: dict = check_eligibility_all_battery(
        sequence_data, SP800_22R1A_BATTERY)
    # Print the eligible tests
    print("Eligible test from NIST-SP800-22r1a:")
    for name in eligible_battery.keys():
        print("-" + name)
        # Test the sequence on the eligible tests
        results = run_all_battery(
            sequence_data, eligible_battery, False)
        # Print results one by one
    print("Test results:")
    for result, elapsed_time in results:
        if result.passed:
            print("- PASSED - score: " + str(np.round(result.score, 3)) + " - " +
                  result.name + " - elapsed time: " + str(elapsed_time) + " ms")
        else:
            print("- FAILED - score: " + str(np.round(result.score, 3)) + " - " +
                  result.name + " - elapsed time: " + str(elapsed_time) + " ms")


def main():
    # Generate the sequence of integers and pack it in its 8-bit representation
    # sequence: np.ndarray = np.random.randint(-128, 128, 1000, dtype=int)
    # binary_sequence: np.ndarray = pack_sequence(sequence)

    chebyshev_sequence, tent_sequence, logistic_sequence = generate_data(
        100000)
    # print("Random Logistic sequence generated by NumPy:")
    # print(logistic_sequence)
    # print("Random Tent sequence generated by NumPy:")
    # print(tent_sequence)

    binary_chebyshev_sequence: np.ndarray = pack_sequence(chebyshev_sequence)
    # print("Random Chebyshev sequence generated by NumPy encoded in 8-bit signed format:")
    # print(binary_chebyshev_sequence)

    binary_logistic_sequence: np.ndarray = pack_sequence(logistic_sequence)
    # print("Random Logistic sequence generated by NumPy encoded in 8-bit signed format:")
    # print(binary_logistic_sequence)

    binary_tent_sequence: np.ndarray = pack_sequence(tent_sequence)
    # print("Random Tent sequence generated by NumPy encoded in 8-bit signed format:")
    # print(binary_tent_sequence)

    # Print sequence
    # print("Random sequence generated by NumPy:")
    # print(sequence)
    # print("Random sequence generated by NumPy encoded in 8-bit signed format:")
    # print(binary_sequence)
    # print("Original sequence taken back by unpacking (to check the correctness of packing process:")
    # print(unpack_sequence(binary_sequence))
    # print("Random Chebyshev sequence generated by NumPy:")
    # print(chebyshev_sequence)
    # print("|----------------------------------------------------------------------------|")
    # print("Random Chebyshev sequence generated by NumPy encoded in 8-bit signed format:")
    # print(binary_chebyshev_sequence)

    # print("Original Chebyshev sequence taken back by unpacking (to check the correctness of packing process:")
    # print(unpack_sequence(binary_chebyshev_sequence))
    test("CHEBYSHEV", binary_chebyshev_sequence)
    test("TENT", binary_tent_sequence)
    test("LOGISTIC", binary_logistic_sequence)


main()
